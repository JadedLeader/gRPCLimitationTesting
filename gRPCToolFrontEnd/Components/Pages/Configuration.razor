@using Grpc.Core
@using gRPCToolFrontEnd.Components.Layout
@using gRPCToolFrontEnd.Services
@using gRPCToolFrontEnd.Helpers
@using Serilog
@using Grpc.Net.Client
@using gRPCToolFrontEnd.LocalStorage
@page "/"
@layout MainLayout
@inject ClientInstanceService ClientInstanceService
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject UnaryRequestService UnaryRequestService
@inject ClientHelper ClientHelper
@inject AccountDetailsStore AccountDetailsStore

<HeadContent>
    <link href="/Style/LoginPage.css" rel="stylesheet" />
</HeadContent>



<MudPaper Class="d-flex justify-start flex-grow-1 gap-4" Elevation="15" Style="width: 300px; padding-left: 20px; background-color: transparent;" Square="true" >

    <MudSelect T="string" Label="Request flow" MultiSelection="false" ValueChanged="@OnRequestFlowChanged" >

    @foreach (string options in _RequestFlowOptions)
    {
        <MudSelectItem T="string" Value="@options">@options</MudSelectItem>
    }

</MudSelect>

</MudPaper>


<MudPaper Class="d-flex justify-start flex-grow-1 gap-4" Elevation="15" Style="width: 300px; background-color: transparent; padding-top: 30px;" Square="true">

<MudToggleIconButton @bind-Toggled="@_StreamingOn" Icon="Icons.Material.Filled.AlarmOff" Color="@Color.Primary" ToggledIcon="@Icons.Material.Filled.AlarmOn"
                     ToggledColor="@Color.Success" title="@(_StreamingOn ? "On" : "Off")" Style="margin-top: 0; padding: 0;" />

<span>Streaming is @(_StreamingOn? "On" : "Off")</span>

    <MudToggleIconButton @bind-Toggled="@_UnaryOrBatch" Icon="Icons.Material.Filled.AlarmOff" Color="@Color.Primary" ToggledIcon="@Icons.Material.Filled.AlarmOn"
                         ToggledColor="@Color.Success" title="@(_UnaryOrBatch ? "Unary" : "Batch")" Style="margin-top: 0; padding: 0;" />

    <span>Communication type is @(_UnaryOrBatch ? "Unary" : "Batch")</span>

</MudPaper>


<MudGrid Spacing="4" Justify="Justify.Center">
    <MudItem xs="12" sm="7" >
        <MudForm @ref="form" Style="background-color: #1A1A1D" >

            <MudCard Style="background: #252525">
                
                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                        <MudGrid Spacing="2"> 
                        <MudItem xs="12" sm="6">

                                <MudTextField font-style="Montserrat" Disabled="@_IsClientInstanceDisabled" @bind-value="@_ClientUnique" Class="MyMudTextField" T="string" Label="Client Instance Unique" Required="true" RequiredError="A client instance is required!" HelperText="Input client instance ID above:" Margin="Margin.Dense"></MudTextField>

                        </MudItem>
                    </MudGrid>
                </MudPaper>

                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                        <MudGrid Spacing="2"> 
                        <MudItem xs="12" sm="6">

                            <MudTextField font-style="Montserrat" @bind-value="@_FileSize" Class="MyMudTextField" T="string" Label="File Size" Required="true" RequiredError="A file size of small, medium or large is required to determine the payload size!" HelperText="Input file size above:" Margin="Margin.Dense"></MudTextField>

                        </MudItem>
                    </MudGrid>
                </MudPaper>

                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                        <MudGrid Spacing="2"> 
                        <MudItem xs="12" sm="6">

                            <MudTextField font-style="Montserrat"  @bind-value="@_Iterations" Class="MyMudTextField" T="int" Label="Batch Iterations" Required="true" RequiredError="A number of batch iterations is required, to determine the amount of requests in a single batch!" HelperText="Input number of batch iterations above:" Margin="Margin.Dense"></MudTextField>

                        </MudItem>
                    </MudGrid>
                </MudPaper>

                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                    <MudGrid Spacing="2">
                         <MudItem xs="12" sm="6">

                             <MudTextField font-style="Montserrat" Disabled="@_IsBatchIterationsDisabled" @bind-value="@_RequestCount" Class="MyMudTextField" T="int" Label="Amount Of Request" Required="true" RequiredError="An amount of requests is required to determine how many requests to be sent!" HelperText="Input amount of requests above:" Margin="Margin.Dense"></MudTextField>

                         </MudItem>
                    </MudGrid>
                </MudPaper>

            
            </MudCard>

            <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                <MudGrid Spacing="2"> 
                    <MudItem xs="12" sm="6">

                        <MudTextField font-style="Montserrat" @bind-value="@_ChannelId" Class="MyMudTextField" T="string" Label="Channel ID" Required="true" RequiredError="A channel ID is required!" HelperText="Input channel ID above:" Margin="Margin.Dense"></MudTextField>

                    </MudItem>
                </MudGrid>
            </MudPaper>

            <MudPaper Class="pa-4 mt-4 justify-start" Style="background: rgba(20, 20, 20, 0.9)">
                <MudGrid Spacing="6" Justify="Justify.SpaceEvenly">

                    <MudItem>
                        <MudTooltip Text="This will apply the current configuration settings"> 
                            <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="true" @onclick="@GenerateClients" Disabled="@_IsApplyConfigDisabled">Apply Configuration Settings</MudButton>
                        </MudTooltip>
                    </MudItem>


                    <MudItem> 
                        <MudTooltip Text="This will clear all of the client instances"> 
                            <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@ClearClientInstances">Clear Client Instances</MudButton>
                        </MudTooltip>
                    </MudItem>

                    <MudItem>
                        <MudTooltip Text="This will send a single unary request (only use for one : one)">
                        <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@SendUnaryRequest" Disabled="@_IsUnaryRequestDisabled">Send single unary request</MudButton>
                        </MudTooltip>
                    </MudItem>

                    <MudItem> 
                        <MudTooltip Text="This will send a single batch request (only use for one : one)">
                        <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@SendBatchUnaryRequest" Disabled="@_IsBatchRequestDisabled">Send batch unary request</MudButton>
                        </MudTooltip>
                    </MudItem>

                    <MudItem>
                        <MudTooltip Text="This should be used for all requests excluding one : one, this dynamically generates the requests">
                        <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@ManyClientsUnaryRequestAsync" >Send different types of request</MudButton>
                        </MudTooltip>
                    </MudItem>
                
            
                </MudGrid>
            </MudPaper>

        </MudForm>
    </MudItem>
</MudGrid>

@code {


    MudForm form;

    private int AmountOfClients;

    private int _RequestCount;

    private int _Iterations;

    private string _ClientUnique;

    private string _FileSize;

    private string _ChannelId;

    private string _RequestFlow;

    private bool _IsBatchRequestDisabled { get; set; } = false;

    private bool _IsUnaryRequestDisabled;

    private bool _IsApplyConfigDisabled;

    private bool _IsClientInstanceDisabled; 

    private bool _IsBatchIterationsDisabled; 

    private bool _IsClientNumberDisabled;

    private bool _OtherRequests { get; set;} = true;

    public bool _StreamingOn { get; set; } = true;

    public bool _UnaryOrBatch { get; set; } = true;

    /// <summary>
    /// This list holds all of the options for the mudblazor mudselect 
    /// one : one -> one channel, one client instance, one request (single unary / batch unary)
    /// one : many -> one channel, many client instance, many requests (be this single unary or batch unary)
    /// many : one -> many channels, many client instances, one request on each channel 
    /// many : many -> many channels, many client instances, many requests on each channel (can be a mix of batch / single / sequential)
    /// </summary>
    private List<string> _RequestFlowOptions = new List<string>()
    {
        "one : one",
        "one : many",
        "many : one",
        "many : many"
    };


    private List<Guid> ClientList = new List<Guid>();

    private List<Guid> ClientListFromDb = new List<Guid>();

    /// <summary>
    /// This method handles the request flow of the page based on the UI state
    /// Effectively just enables/disables text fields and buttons
    /// </summary>
    /// <param name="value"></param>
    /// <returns></returns>
    private async Task OnRequestFlowChanged(string value)
    {
        Log.Information($"Selected Request Flow: {value}");
        _RequestFlow = value;
        await HandlingCommunications();
    }

    /// <summary>
    /// This has turned into the over-arching implementation method for sending several different types of request
    /// This currently handles many : one , one : many and many : many
    /// one : one is handled in a more simplistic fashion
    /// </summary>
    /// <returns></returns>
    private async Task ManyClientsUnaryRequestAsync()
    {
        Log.Information($"Streaming state: {_StreamingOn}");
        Log.Information($"Request flow: {_RequestFlow}"); 
        Log.Information($"Unary or batch state: {_UnaryOrBatch}"); 

        await ManyClientsUnaryRequest(_StreamingOn, _RequestFlow, _UnaryOrBatch, _RequestCount, AccountDetailsStore.channels);
    }

    /// <summary>
    /// This method is in charge of what message types can be sent based on the UI state
    /// if streaming is false, we know that it can only be unary requests, if streaming is true, we know that it will be streaming requests (no current support for both)
    /// Drop down state is a string that gets returned based on the dropdown box on the UI which has four different states depicated in the _RequestFlowOptions property 
    /// The general idea is that one -> "X" requests, require a channel ID to be performed (as there may be more than one channel generated)
    /// one -> "X" requests can be both unary or streaming, determined by the UI state
    /// many -> "X" requests require a list of channels to iterate over in order to send the requests (no channel ID is required to be passed)
    /// again, many -> "X" requests can be both unary or streaming, determined by the UI state
    /// </summary>
    /// <param name="isStreaming">true for streaming requests, false for unary requests</param>
    /// <param name="dropDownState">string returned from the dropdown box on the UI component</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <param name="channelDict">the dictionary of channels currently in local storage</param>
    /// <returns></returns>
    public async Task ManyClientsUnaryRequest(bool isStreaming, string dropDownState, bool unaryOrBatch, int requestCount ,Dictionary<Guid, GrpcChannel> channelDict)
    {
        if (!isStreaming && dropDownState == "many : one" )
        {
            Log.Information($"Many to one request detected");
            Log.Information($"Amount of clients to generate requests for {channelDict.Count}");

            foreach (var channel in channelDict)
            {
                await HandlingManyToOneRequests(channelDict, unaryOrBatch);
            }
        }
        else if (!isStreaming && dropDownState == "one : many")
        {
            Log.Information($"One to many request detected");
            await HandlingOneToManyRequests(requestCount, unaryOrBatch);

        }
        else if (!isStreaming && dropDownState == "many : many")
        {
            Log.Information($"many to many request detected");
            Log.Information($"Amount of clients to generate requests for {channelDict.Count}");
            await HandlingManyToManyRequests(channelDict, requestCount, unaryOrBatch);
        }

    }

    /// <summary>
    /// Function for handling the many to one request types
    /// Decides between unary and batch based on the UI state
    /// </summary>
    /// <param name="channelDict">Dictionary of channels that are currently created locally</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <returns></returns>
    private async Task HandlingManyToOneRequests(Dictionary<Guid, GrpcChannel> channelDict, bool unaryOrBatch)
    {
        if(unaryOrBatch)
        {
            await SendUnaryRequest(); 
        }
        else
        {
            string clientUnique = await CreateSingularClientInstance();

            await SendUnaryBatchIterativeRequest(clientUnique);

        }
    }

    /// <summary>
    /// This function is by far the most complex and handles many : many requests 
    /// Chooses between unary and batch
    /// If it's unary, the encompassing function handles the logic
    /// If it's batch, we use a while loop to iterate over the sending a batch, this ensures we get the correct amount of requests
    /// </summary>
    /// <param name="channelDict">Dictionary containing the channels currently created locally</param>
    /// <param name="requestCount">The amount of requests the user wants to send of that request type</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <returns></returns>
    private async Task HandlingManyToManyRequests(Dictionary<Guid, GrpcChannel> channelDict, int requestCount, bool unaryOrBatch)
    {
        Log.Information($"Request count for many to many request : {requestCount} ");

        int i = 0;

        if(unaryOrBatch)
        {
            await SendUnaryIterativeRequest();
        }
        else
        {
            while(i < requestCount)
            {
                string newClientInstance = await CreateSingularClientInstance();

                await SendUnaryBatchIterativeRequest(newClientInstance);

                i++;
            }
        }

    }

    /// <summary>
    /// This function handles the one : many case
    /// It chooses between unary or batch
    /// Dependant upon the request type, we iterate over the different request types
    /// </summary>
    /// <param name="requestCount">The amount of requests the user wants to send</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <returns></returns>
    private async Task HandlingOneToManyRequests(int requestCount, bool unaryOrBatch)
    {
        int i = 0; 

        if(unaryOrBatch)
        {
            Log.Information($"unary request detected");

            while(i < requestCount)
            {
                await SendUnaryIterativeRequest();

                Log.Information($"Unary request: {i} created");

                i++;
            }
        }
        else
        {
            Log.Information($"Batch request detected");

            while(i < requestCount)
            {
                string clientUnique = await CreateSingularClientInstance();

                await SendUnaryBatchIterativeRequest(clientUnique);

                Log.Information($"Batch request: {i} created");

                i++;
            }
        }
    }


    /// <summary>
    /// This is used on the batch unary request and the single unary request 
    /// Since we only really need to generate mass amount of clients for one to many or many to many request types 
    /// Singular requests should just have a client instance created for them
    /// </summary>
    /// <returns></returns>
    private async Task<string> CreateSingularClientInstance()
    {
        string username = await GetStringFromStringFromLocalStorage("username");

        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        CreateClientInstanceRequest newClientInstance = new CreateClientInstanceRequest
        {
             Username = username,
             SessionUnique = sessionUnique
        };

        CreateClientInstanceResponse serverResponse = await ClientInstanceService.CreateClientInstanceAsync(newClientInstance);

        if(serverResponse.SessionUnique == null)
        {
            Log.Warning($"Something went wrong when creating a singular client instance");
        }

        return serverResponse.ClientUnique;
    }

    /// <summary>
    /// this is used as the overhead method for generating clients
    /// All it does is generate a number of clients determined by the client 
    /// And then sends them to the server to be stored in the database
    /// </summary>
    /// <returns></returns>
    private async Task GenerateClients()
    {
        await GeneratingClientInstances();

        await SendClientsToBackend();
    }

    /// <summary>
    /// This is used for sending a single unary request on a single channel
    /// A new unary client instance is generated in the service of this method call every time the endpoint is activated
    /// </summary>
    /// <returns></returns>
    private async Task SendUnaryRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique;

        await GenerateUnaryRequest();
    }

    private async Task SendUnaryIterativeRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique;

        await GenerateUnaryRequestIterative();
    }

    private async Task SendUnaryBatchIterativeRequest(string clientUnique)
    {
        var channels = AccountDetailsStore.GetChannels();

        string filePath = ClientHelper.FileSize(_FileSize);

        string content = File.ReadAllText(filePath);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        foreach (var channel in channels)
        {
            Unary.UnaryClient newUnaryClient = new Unary.UnaryClient(channel.Value);

            Metadata metaData = new Metadata();

            //GENERATE A NEW BATCH REQUEST ID FOR EVERY NEW REQUEST
            string batchRequestId = Guid.NewGuid().ToString();
            string preciseTime = DateTime.UtcNow.ToString("HH:mm:ss.ffffff");

            metaData.Add("batch-request-id", batchRequestId);
            metaData.Add("batch-request-timestamp", preciseTime);
            metaData.Add("request-type", "BatchUnary");
            metaData.Add("batch-request-count", "1");
            metaData.Add("active-clients", "1");

            List<BatchDataRequestDetails> batchRequests = new List<BatchDataRequestDetails>
            {
                new BatchDataRequestDetails
                {
                    ClientUnique = clientUnique, 
                    RequestId = Guid.NewGuid().ToString(),
                    DataSize = "1MB",
                    RequestTimestamp = preciseTime,
                    RequestType = "BatchUnary",
                    DataContent = dataContent,


                }
            };

            BatchDataRequest batchDataRequest = new BatchDataRequest { BatchDataRequest_ = { batchRequests } };

            Log.Information($"Sending batch unary request on channel {channel.Key} with client ID {clientUnique}");

            await newUnaryClient.BatchUnaryResponseAsync(batchDataRequest, metaData);
        }
    }

    /// <summary>
    /// This is used for sending a batch unary request on a single channel
    /// A new unary client instance is generated in the service of this method call every tim the endpoint is activated
    /// </summary>
    /// <returns></returns>
    private async Task SendBatchUnaryRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique; 

        await GenerateBatchUnaryRequest();
    }



    /// <summary>
    /// Handles the communication flow of the forms on the front end depending on what drop down option is currently selected 
    /// Essentially just flips between true and false to disable buttons and input fields
    /// Then calls StateHasChanged to force a page refresh
    /// </summary>
    /// <returns></returns>
    public async Task HandlingCommunications()
    {
        Log.Information($"HandlingCommunications called with _RequestFlow: {_RequestFlow}");

        switch (_RequestFlow)
        {
            case "one : one":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsApplyConfigDisabled = true;
                _IsClientInstanceDisabled = true;
                _IsClientNumberDisabled = true;
                _IsBatchIterationsDisabled = true;
                _OtherRequests = true;

                break;

            case "one : many":
                _IsUnaryRequestDisabled = false;
                _IsBatchRequestDisabled = false;
                _IsApplyConfigDisabled = true;
                _IsClientNumberDisabled = true; 
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                _IsUnaryRequestDisabled = true;
                _IsBatchRequestDisabled = true;
                break;

            case "many : one":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                _IsClientNumberDisabled = true;
                _IsBatchRequestDisabled = true;
                _IsUnaryRequestDisabled = true;
                _IsBatchRequestDisabled = true;
                break;

            case "many : many":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                _IsUnaryRequestDisabled = true;
                _IsBatchRequestDisabled = true;
                break;

            default:
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                break;
        }

        StateHasChanged();
    } 

    /// <summary>
    /// This method is in charge of generating handling a list of BatchDataRequestDetails, adding them to the request as this is a repeated field (bulk upload to the server)
    /// 
    /// </summary>
    /// <returns></returns>
    private async Task GenerateBatchUnaryRequest()
    {

        List<BatchDataRequestDetails> dataRequestDetails = await GeneratingBatchOfRequests(_Iterations);

        Log.Information($"Amount of requests in the data request list: {dataRequestDetails.Count}");

        BatchDataRequest batchDataRequestUnary = new BatchDataRequest
        {
             BatchDataRequest_ = { dataRequestDetails }
        };

        await UnaryRequestService.UnaryBatchResponseAsync(batchDataRequestUnary, _Iterations, Guid.Parse(_ChannelId));
    }

    private async Task GenerateBatchUnaryRequestIterative()
    {
        List<BatchDataRequestDetails> dataRequestDetails = await GeneratingBatchOfRequests(_Iterations);

        Log.Information($"Amount of requests in the data request list: {dataRequestDetails.Count}");

        BatchDataRequest batchDataRequestUnary = new BatchDataRequest
            {
                BatchDataRequest_ = { dataRequestDetails }
            };

        var thing = await UnaryRequestService.UnaryBatchIterativeAsync(batchDataRequestUnary, _Iterations);
    }

    private async Task GenerateUnaryRequestIterative()
    {
        string filePath = ClientHelper.FileSize(_FileSize);

        string content = File.ReadAllText(filePath);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string newGuid = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        DataRequest newDataRequest = new DataRequest
            {
                ClientUnique = _ClientUnique,
                ConnectionAlive = false,
                DataContent = dataContent,
                RequestType = "Unary",
                DataSize = _FileSize,
                RequestId = newGuid,
                RequestTimestamp = preciseTime
            };

        Log.Information($"Client ID: {newDataRequest.ClientUnique} has sent message ID: {newDataRequest.RequestId} at {newDataRequest.RequestTimestamp}");

        var serverResponse = await UnaryRequestService.UnaryResponseIterativeAsync(newDataRequest);


    }

    /// <summary>
    /// This method is in charge of generating each request that goes into the batch of unary requests 
    /// While loop to generate the requests until we reach the amount of requests required in the batch
    /// </summary>
    /// <param name="requestIterations"> is how many messages you want to be in the batch</param>
    /// <returns>A list of BatchDataRequestDetails populated with as many requests stated in the parameter</returns>
    private async Task<List<BatchDataRequestDetails>> GeneratingBatchOfRequests(int requestIterations)
    {
        List<BatchDataRequestDetails> dataRequestDetails = new List<BatchDataRequestDetails>();

        string filePath = ClientHelper.FileSize(_FileSize);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string batchRequestId = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        int i = 0; 

        while(i < requestIterations)
        {

            BatchDataRequestDetails singleRequest = new BatchDataRequestDetails
            {
                ClientUnique = _ClientUnique, 
                ConnectionAlive = true, 
                DataContent = dataContent, 
                DataSize = _FileSize, 
                RequestId = Guid.NewGuid().ToString(), 
                RequestTimestamp = preciseTime, 
                RequestType = "BatchUnary",
                BatchRequestId = batchRequestId


            };

            Log.Information($"New batch data request has been added to the batch, request is owned by client ID {singleRequest.ClientUnique} with over-arching ID : {singleRequest.BatchRequestId} handles {singleRequest.RequestId}");

            dataRequestDetails.Add(singleRequest);

            i++;
        }

        return dataRequestDetails;
    }

    /// <summary>
    /// This function is in charge of gathering all the parameters to generate a DataRequest
    /// This is a unary-unary request so it's straight forward
    /// </summary>
    /// <returns></returns>
    private async Task GenerateUnaryRequest()
    {
        string filePath = ClientHelper.FileSize(_FileSize);

        string content = File.ReadAllText(filePath);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string newGuid = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        var thing = _ClientUnique;

        DataRequest newDataRequest = new DataRequest
        {
            ClientUnique = _ClientUnique, 
            ConnectionAlive = false, 
            DataContent = dataContent, 
            RequestType = "Unary", 
            DataSize = _FileSize, 
            RequestId = newGuid, 
            RequestTimestamp = preciseTime
        };

        Log.Information($"Client ID: {newDataRequest.ClientUnique} has sent message ID: {newDataRequest.RequestId} at {newDataRequest.RequestTimestamp}");

        DataResponse serverResponse = await UnaryRequestService.UnaryResponseAsync(newDataRequest, Guid.Parse(_ChannelId));

        if(serverResponse.RequestId == null || serverResponse.ClientUnique == null)
        {
            Log.Information($"Something went wrong, the server responded with no requestID or clientID"); 
        }


    }

    /// <summary>
    /// Clears all the client instances within the database based on the session unique
    /// This is currently a unary -> unary implementation
    /// </summary>
    /// <returns></returns>
    private async Task ClearClientInstances()
    {
        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        ClientListFromDb.Clear();

        GetClientInstancesFromSessionUniqueRequest request = new GetClientInstancesFromSessionUniqueRequest
        {
                SessionUnique = sessionUnique
        };

        //THIS DELETES THE CURRENT RECORDS IN A UNARY MATTER - i want to try and get this to work in a streaming fashion
        await ClientInstanceService.GetClientInstancesAsync(request);
    }

    /// <summary>
    /// Generates a list of clients, adds them to the private list with their new guid
    /// </summary>
    /// <returns></returns>
    private async Task GeneratingClientInstances()
    {
        int i = 0;

        while (i < AmountOfClients)
        {
            ClientList.Add(Guid.NewGuid());

            Log.Information($"amount of things in client list {i}");

            i++;
        }
    }


    private async Task SendClientsToBackend()
    {
        string username = await GetStringFromStringFromLocalStorage("username");

        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        string accountUnique = await GetStringFromStringFromLocalStorage("account-unique");

        await ClientInstanceService.CreatingClientInstancesStreamedAsync(sessionUnique, accountUnique, ClientList);
    }

    /// <summary>
    /// Allows for the retrieval of a string from the local storage
    /// </summary>
    /// <param name="storagekey">the key identifier of the item in local storage</param>
    /// <returns>The string value of they key specified</returns>
    private async Task<string> GetStringFromStringFromLocalStorage(string storagekey)
    {
        string? localStorageUsername = await LocalStorage.GetItemAsync<string>(storagekey);

        if(string.IsNullOrEmpty(localStorageUsername))
        {
            Log.Information($"key {storagekey} cannot be found in the local storage");
            return "";
        }

        return localStorageUsername;
    }     
    
}
