@using Grpc.Core
@using gRPCToolFrontEnd.Components.Layout
@using gRPCToolFrontEnd.Services
@using gRPCToolFrontEnd.Helpers
@using Serilog
@using Grpc.Net.Client
@using gRPCToolFrontEnd.LocalStorage
@using System.Reactive.Subjects
@using gRPCToolFrontEnd.DictionaryModel
@using System.Collections.Concurrent
@page "/"
@layout MainLayout
@inject ClientInstanceService ClientInstanceService
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject UnaryRequestService UnaryRequestService
@inject ClientHelper ClientHelper
@inject AccountDetailsStore AccountDetailsStore
@inject UtilitiesService UtilitiesService

<MudGrid Class="d-flex" Style="padding: 20px; height: 100vh; overflow: hidden;">
    <!-- Left Tree View Section -->
    <MudItem xs="12" sm="4" Style="height: 100%;">
        <MudPaper Elevation="10" Class="MyTreeViewContainer">
            <MudTreeView T="string" SelectionMode="SelectionMode.SingleSelection">
                <MudTreeViewItem Value='"Client instances with messages"'>
                    @foreach (var clientInstance in _ClientsWithMessages)
                    {
                        <MudTreeViewItem Text="@clientInstance.Key.ToString()" Expanded="false">
                            @foreach (var messageDelay in clientInstance.Value)
                            {
                                <MudTreeViewItem Text="@($"{messageDelay.MessageId} : RequestType {messageDelay.RequestType} : Delay : {messageDelay.MessageDelay}")" />
                            }
                        </MudTreeViewItem>
                    }
                </MudTreeViewItem>
            </MudTreeView>
        </MudPaper>
    </MudItem>

    <!-- Right Content Section -->
    <MudItem xs="12" sm="8" Style="height: 100%; overflow-y: auto;">
        <!-- Dropdown and Toggle Buttons Section -->
        <MudGrid Class="d-flex justify-end align-center" Style="margin-bottom: 20px;">
            <MudItem>
                <MudSelect T="string" Label="Request flow" MultiSelection="false" ValueChanged="@OnRequestFlowChanged" Style="margin-right: 20px; min-width: 200px;">
                    @foreach (string options in _RequestFlowOptions)
                    {
                        <MudSelectItem T="string" Value="@options">@options</MudSelectItem>
                    }
                </MudSelect>

                <MudToggleIconButton @bind-Toggled="@_StreamingOn"
                                     Icon="Icons.Material.Filled.AlarmOff"
                                     ToggledIcon="@Icons.Material.Filled.AlarmOn"
                                     ToggledColor="@Color.Success"
                                     title="@(_StreamingOn ? "Streaming On" : "Streaming Off")"
                                     Style="margin-right: 20px;" />

                <span>Streaming is @(_StreamingOn ? "On" : "Off")</span>

                <MudToggleIconButton @bind-Toggled="@_UnaryOrBatch"
                                     Icon="Icons.Material.Filled.AlarmOff"
                                     ToggledIcon="@Icons.Material.Filled.AlarmOn"
                                     ToggledColor="@Color.Success"
                                     title="@(_UnaryOrBatch ? "Unary" : "Batch")"
                                     Style="margin-right: 20px;" />

                <span>Communication type is @(_UnaryOrBatch ? "Unary" : "Batch")</span>

                <button @onclick="StartReceivingStream">Start Receiving Messages</button>

            </MudItem>
        </MudGrid>

        <!-- Form Section -->
        <MudPaper Elevation="10" Class="pa-4 mt-4" Style="background: rgba(20, 20, 20, 0.9);">
            <MudForm @ref="form">
                <MudCard Style="background: #252525; padding: 20px;">
                    <!-- Input Fields -->
                    <MudTextField Label="Client Instance Unique"
                                  @bind-Value="_ClientUnique"
                                  Required="true"
                                  Class="MyMudTextField"
                                  Style="margin-bottom: 20px;" />

                    <MudTextField Label="File Size"
                                  @bind-Value="_FileSize"
                                  Required="true"
                                  Class="MyMudTextField"
                                  Style="margin-bottom: 20px;" />

                    <MudTextField Label="Batch Iterations"
                                  @bind-Value="_Iterations"
                                  T="int"
                                  Required="true"
                                  Class="MyMudTextField"
                                  Style="margin-bottom: 20px;" />

                    <MudTextField Label="Amount Of Request"
                                  @bind-Value="_RequestCount"
                                  T="int"
                                  Required="true"
                                  Class="MyMudTextField"
                                  Style="margin-bottom: 20px;" />

                    <MudTextField Label="Channel ID"
                                  @bind-Value="_ChannelId"
                                  Required="true"
                                  Class="MyMudTextField"
                                  Style="margin-bottom: 20px;" />
                </MudCard>

                <!-- Buttons Section -->
                <MudPaper Class="mt-4 pa-2 d-flex justify-space-between flex-wrap" Style="background: rgba(20, 20, 20, 0.9);">
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@GenerateClients" Style="flex: 1; margin: 5px; color: white;">Apply Configuration</MudButton>
                    <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="@ClearClientInstances" Style="flex: 1; margin: 5px; color: white;">Clear Clients</MudButton>
                    <MudButton Variant="Variant.Filled" Color="Color.Info" OnClick="@SendUnaryRequest" Style="flex: 1; margin: 5px; color: white;">Send Unary</MudButton>
                    <MudButton Variant="Variant.Filled" Color="Color.Success" OnClick="@SendBatchUnaryRequest" Style="flex: 1; margin: 5px; color: white;">Send Batch Unary</MudButton>
                    <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="@ManyClientsUnaryRequestAsync" Style="flex: 1; margin: 5px; color: white;">Send Different Requests</MudButton>
                </MudPaper>
            </MudForm>
        </MudPaper>
    </MudItem>
</MudGrid>


<style>

    .MyTreeViewContainer {
        background: rgba(0, 0, 0, 0.6);
        border-radius: 12px;
        padding: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        height: 100%; /* Ensure it stretches only within the parent */
        max-height: 80vh; /* Limits the height to 80% of the viewport height */
        overflow-y: auto; /* Enables vertical scrolling for overflow */
        scrollbar-width: thin; /* For Firefox */
        scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
    }

    .MyTreeViewContainer::-webkit-scrollbar {
        width: 8px;
    }

    .MyTreeViewContainer::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
    }

    .MyTreeViewContainer::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.4);
    }
  
    .MyMudTextField {
        width: 100%;
    }

    .MyLoginMudButton {
        flex: 1;
        margin: 5px;
    }

    .d-flex {
        display: flex;
    }

    .justify-end {
        justify-content: flex-end;
    }

    .justify-space-between {
        justify-content: space-between;
    }

    .align-center {
        align-items: center;
    }

    button {
        color: white !important;
    }
</style>

@code {


    MudForm form;

    private int AmountOfClients;

    private int _RequestCount;

    private int _Iterations;

    private string _ClientUnique;

    private string _FileSize;

    private string _ChannelId;

    private string _RequestFlow;

    private bool _IsBatchRequestDisabled { get; set; } = false;

    private bool _IsUnaryRequestDisabled;

    private bool _IsApplyConfigDisabled;

    private bool _IsClientInstanceDisabled; 

    private bool _IsBatchIterationsDisabled; 

    private bool _IsClientNumberDisabled;

    private bool _OtherRequests { get; set;} = true;

    public bool _StreamingOn { get; set; } = true;

    public bool _UnaryOrBatch { get; set; } = true;

    private bool _UiUpdating = true;

    private ConcurrentDictionary<Guid, List<Delay>> _ClientsWithMessages = new();

    private BehaviorSubject<Dictionary<Guid, List<Delay>>> _ClientWithMessagesSubject;

    private IDisposable _ClientWithMessagesSubscription;

    protected override async void OnInitialized()
    {
        _ClientWithMessagesSubject = new BehaviorSubject<Dictionary<Guid, List<Delay>>>(new Dictionary<Guid, List<Delay>>());

        
        _ClientWithMessagesSubscription = _ClientWithMessagesSubject.Subscribe(updatedDict =>
        {
            InvokeAsync(StateHasChanged); 
        });

        await StartReceivingStream();
    }

    private async Task StartReceivingStream()
    {
        Log.Information($"Starting the stream");

        var request = new GetClientsWithMessagesRequest(); 

        await UtilitiesService.ReceivingMessageStream(request, _ClientsWithMessages, _UiUpdating, _ClientWithMessagesSubject);

        _ClientWithMessagesSubject.OnNext(new Dictionary<Guid, List<Delay>>(_ClientsWithMessages));
    }

    /// <summary>
    /// This list holds all of the options for the mudblazor mudselect 
    /// one : one -> one channel, one client instance, one request (single unary / batch unary)
    /// one : many -> one channel, many client instance, many requests (be this single unary or batch unary)
    /// many : one -> many channels, many client instances, one request on each channel 
    /// many : many -> many channels, many client instances, many requests on each channel (can be a mix of batch / single / sequential)
    /// </summary>
    private List<string> _RequestFlowOptions = new List<string>()
    {
        "one : one",
        "one : many",
        "many : one",
        "many : many"
    };


    private List<Guid> ClientList = new List<Guid>();

    private List<Guid> ClientListFromDb = new List<Guid>();

    /// <summary>
    /// This method handles the request flow of the page based on the UI state
    /// Effectively just enables/disables text fields and buttons
    /// </summary>
    /// <param name="value"></param>
    /// <returns></returns>
    private async Task OnRequestFlowChanged(string value)
    {
        Log.Information($"Selected Request Flow: {value}");
        _RequestFlow = value;
        await HandlingCommunications();
    }

    /// <summary>
    /// This has turned into the over-arching implementation method for sending several different types of request
    /// This currently handles many : one , one : many and many : many
    /// one : one is handled in a more simplistic fashion
    /// </summary>
    /// <returns></returns>
    private async Task ManyClientsUnaryRequestAsync()
    {
        Log.Information($"Streaming state: {_StreamingOn}");
        Log.Information($"Request flow: {_RequestFlow}"); 
        Log.Information($"Unary or batch state: {_UnaryOrBatch}"); 

        await ManyClientsUnaryRequest(_StreamingOn, _RequestFlow, _UnaryOrBatch, _RequestCount, AccountDetailsStore.channels);
    }

    /// <summary>
    /// This method is in charge of what message types can be sent based on the UI state
    /// if streaming is false, we know that it can only be unary requests, if streaming is true, we know that it will be streaming requests (no current support for both)
    /// Drop down state is a string that gets returned based on the dropdown box on the UI which has four different states depicated in the _RequestFlowOptions property 
    /// The general idea is that one -> "X" requests, require a channel ID to be performed (as there may be more than one channel generated)
    /// one -> "X" requests can be both unary or streaming, determined by the UI state
    /// many -> "X" requests require a list of channels to iterate over in order to send the requests (no channel ID is required to be passed)
    /// again, many -> "X" requests can be both unary or streaming, determined by the UI state
    /// </summary>
    /// <param name="isStreaming">true for streaming requests, false for unary requests</param>
    /// <param name="dropDownState">string returned from the dropdown box on the UI component</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <param name="channelDict">the dictionary of channels currently in local storage</param>
    /// <returns></returns>
    public async Task ManyClientsUnaryRequest(bool isStreaming, string dropDownState, bool unaryOrBatch, int requestCount ,Dictionary<Guid, GrpcChannel> channelDict)
    {
        if (!isStreaming && dropDownState == "many : one" )
        {
            Log.Information($"Many to one request detected");
            Log.Information($"Amount of clients to generate requests for {channelDict.Count}");

            foreach (var channel in channelDict)
            {
                await HandlingManyToOneRequests(channelDict, unaryOrBatch);
            }
        }
        else if (!isStreaming && dropDownState == "one : many")
        {
            Log.Information($"One to many request detected");
            await HandlingOneToManyRequests(requestCount, unaryOrBatch);

        }
        else if (!isStreaming && dropDownState == "many : many")
        {
            Log.Information($"many to many request detected");
            Log.Information($"Amount of clients to generate requests for {channelDict.Count}");
            await HandlingManyToManyRequests(channelDict, requestCount, unaryOrBatch);
        }

    }

    /// <summary>
    /// Function for handling the many to one request types
    /// Decides between unary and batch based on the UI state
    /// </summary>
    /// <param name="channelDict">Dictionary of channels that are currently created locally</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <returns></returns>
    private async Task HandlingManyToOneRequests(Dictionary<Guid, GrpcChannel> channelDict, bool unaryOrBatch)
    {
        if(unaryOrBatch)
        {
            await SendUnaryRequest(); 
        }
        else
        {
            string clientUnique = await CreateSingularClientInstance();

            await SendUnaryBatchIterativeRequest(clientUnique);

        }
    }

    /// <summary>
    /// This function is by far the most complex and handles many : many requests 
    /// Chooses between unary and batch
    /// If it's unary, the encompassing function handles the logic
    /// If it's batch, we use a while loop to iterate over the sending a batch, this ensures we get the correct amount of requests
    /// </summary>
    /// <param name="channelDict">Dictionary containing the channels currently created locally</param>
    /// <param name="requestCount">The amount of requests the user wants to send of that request type</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <returns></returns>
    private async Task HandlingManyToManyRequests(Dictionary<Guid, GrpcChannel> channelDict, int requestCount, bool unaryOrBatch)
    {
        Log.Information($"Request count for many to many request : {requestCount} ");

        int i = 0;

        if(unaryOrBatch)
        {
            await SendUnaryIterativeRequest();
        }
        else
        {
            while(i < requestCount)
            {
                string newClientInstance = await CreateSingularClientInstance();

                await SendUnaryBatchIterativeRequest(newClientInstance);

                i++;
            }
        }

    }

    /// <summary>
    /// This function handles the one : many case
    /// It chooses between unary or batch
    /// Dependant upon the request type, we iterate over the different request types
    /// </summary>
    /// <param name="requestCount">The amount of requests the user wants to send</param>
    /// <param name="unaryOrBatch">true for unary, false for batch</param>
    /// <returns></returns>
    private async Task HandlingOneToManyRequests(int requestCount, bool unaryOrBatch)
    {
        int i = 0; 

        if(unaryOrBatch)
        {
            Log.Information($"unary request detected");

            while(i < requestCount)
            {
                await SendUnaryIterativeRequest();

                Log.Information($"Unary request: {i} created");

                i++;
            }
        }
        else
        {
            Log.Information($"Batch request detected");

            while(i < requestCount)
            {
                string clientUnique = await CreateSingularClientInstance();

                await SendUnaryBatchIterativeRequest(clientUnique);

                Log.Information($"Batch request: {i} created");

                i++;
            }
        }
    }


    /// <summary>
    /// This is used on the batch unary request and the single unary request 
    /// Since we only really need to generate mass amount of clients for one to many or many to many request types 
    /// Singular requests should just have a client instance created for them
    /// </summary>
    /// <returns></returns>
    private async Task<string> CreateSingularClientInstance()
    {
        string username = await GetStringFromStringFromLocalStorage("username");

        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        CreateClientInstanceRequest newClientInstance = new CreateClientInstanceRequest
        {
             Username = username,
             SessionUnique = sessionUnique
        };

        CreateClientInstanceResponse serverResponse = await ClientInstanceService.CreateClientInstanceAsync(newClientInstance);

        if(serverResponse.SessionUnique == null)
        {
            Log.Warning($"Something went wrong when creating a singular client instance");
        }

        return serverResponse.ClientUnique;
    }

    /// <summary>
    /// this is used as the overhead method for generating clients
    /// All it does is generate a number of clients determined by the client 
    /// And then sends them to the server to be stored in the database
    /// </summary>
    /// <returns></returns>
    private async Task GenerateClients()
    {
        await GeneratingClientInstances();

        await SendClientsToBackend();
    }

    /// <summary>
    /// This is used for sending a single unary request on a single channel
    /// A new unary client instance is generated in the service of this method call every time the endpoint is activated
    /// </summary>
    /// <returns></returns>
    private async Task SendUnaryRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique;

        await GenerateUnaryRequest();
    }

    private async Task SendUnaryIterativeRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique;

        await GenerateUnaryRequestIterative();
    }

    private async Task SendUnaryBatchIterativeRequest(string clientUnique)
    {
        var channels = AccountDetailsStore.GetChannels();

        string filePath = ClientHelper.FileSize(_FileSize);

        string content = File.ReadAllText(filePath);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        foreach (var channel in channels)
        {
            Unary.UnaryClient newUnaryClient = new Unary.UnaryClient(channel.Value);

            Metadata metaData = new Metadata();

            //GENERATE A NEW BATCH REQUEST ID FOR EVERY NEW REQUEST
            string batchRequestId = Guid.NewGuid().ToString();
            string preciseTime = DateTime.UtcNow.ToString("HH:mm:ss.ffffff");

            metaData.Add("batch-request-id", batchRequestId);
            metaData.Add("batch-request-timestamp", preciseTime);
            metaData.Add("request-type", "BatchUnary");
            metaData.Add("batch-request-count", "1");
            metaData.Add("active-clients", "1");

            List<BatchDataRequestDetails> batchRequests = new List<BatchDataRequestDetails>
            {
                new BatchDataRequestDetails
                {
                    ClientUnique = clientUnique, 
                    RequestId = Guid.NewGuid().ToString(),
                    DataSize = "1MB",
                    RequestTimestamp = preciseTime,
                    RequestType = "BatchUnary",
                    DataContent = dataContent,


                }
            };

            BatchDataRequest batchDataRequest = new BatchDataRequest { BatchDataRequest_ = { batchRequests } };

            Log.Information($"Sending batch unary request on channel {channel.Key} with client ID {clientUnique}");

            await newUnaryClient.BatchUnaryResponseAsync(batchDataRequest, metaData);
        }
    }

    /// <summary>
    /// This is used for sending a batch unary request on a single channel
    /// A new unary client instance is generated in the service of this method call every tim the endpoint is activated
    /// </summary>
    /// <returns></returns>
    private async Task SendBatchUnaryRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique; 

        await GenerateBatchUnaryRequest();
    }



    /// <summary>
    /// Handles the communication flow of the forms on the front end depending on what drop down option is currently selected 
    /// Essentially just flips between true and false to disable buttons and input fields
    /// Then calls StateHasChanged to force a page refresh
    /// </summary>
    /// <returns></returns>
    public async Task HandlingCommunications()
    {
        Log.Information($"HandlingCommunications called with _RequestFlow: {_RequestFlow}");

        switch (_RequestFlow)
        {
            case "one : one":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsApplyConfigDisabled = true;
                _IsClientInstanceDisabled = true;
                _IsClientNumberDisabled = true;
                _IsBatchIterationsDisabled = true;
                _OtherRequests = true;

                break;

            case "one : many":
                _IsUnaryRequestDisabled = false;
                _IsBatchRequestDisabled = false;
                _IsApplyConfigDisabled = true;
                _IsClientNumberDisabled = true; 
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                _IsUnaryRequestDisabled = true;
                _IsBatchRequestDisabled = true;
                break;

            case "many : one":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                _IsClientNumberDisabled = true;
                _IsBatchRequestDisabled = true;
                _IsUnaryRequestDisabled = true;
                _IsBatchRequestDisabled = true;
                break;

            case "many : many":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                _IsUnaryRequestDisabled = true;
                _IsBatchRequestDisabled = true;
                break;

            default:
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                break;
        }

        StateHasChanged();
    } 

    /// <summary>
    /// This method is in charge of generating handling a list of BatchDataRequestDetails, adding them to the request as this is a repeated field (bulk upload to the server)
    /// 
    /// </summary>
    /// <returns></returns>
    private async Task GenerateBatchUnaryRequest()
    {

        List<BatchDataRequestDetails> dataRequestDetails = await GeneratingBatchOfRequests(_Iterations);

        Log.Information($"Amount of requests in the data request list: {dataRequestDetails.Count}");

        BatchDataRequest batchDataRequestUnary = new BatchDataRequest
        {
             BatchDataRequest_ = { dataRequestDetails }
        };

        await UnaryRequestService.UnaryBatchResponseAsync(batchDataRequestUnary, _Iterations, Guid.Parse(_ChannelId));
    }

    private async Task GenerateBatchUnaryRequestIterative()
    {
        List<BatchDataRequestDetails> dataRequestDetails = await GeneratingBatchOfRequests(_Iterations);

        Log.Information($"Amount of requests in the data request list: {dataRequestDetails.Count}");

        BatchDataRequest batchDataRequestUnary = new BatchDataRequest
            {
                BatchDataRequest_ = { dataRequestDetails }
            };

        var thing = await UnaryRequestService.UnaryBatchIterativeAsync(batchDataRequestUnary, _Iterations);
    }

    private async Task GenerateUnaryRequestIterative()
    {
        string filePath = ClientHelper.FileSize(_FileSize);

        string content = File.ReadAllText(filePath);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string newGuid = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        DataRequest newDataRequest = new DataRequest
            {
                ClientUnique = _ClientUnique,
                ConnectionAlive = false,
                DataContent = dataContent,
                RequestType = "Unary",
                DataSize = _FileSize,
                RequestId = newGuid,
                RequestTimestamp = preciseTime
            };

        Log.Information($"Client ID: {newDataRequest.ClientUnique} has sent message ID: {newDataRequest.RequestId} at {newDataRequest.RequestTimestamp}");

        var serverResponse = await UnaryRequestService.UnaryResponseIterativeAsync(newDataRequest);


    }

    /// <summary>
    /// This method is in charge of generating each request that goes into the batch of unary requests 
    /// While loop to generate the requests until we reach the amount of requests required in the batch
    /// </summary>
    /// <param name="requestIterations"> is how many messages you want to be in the batch</param>
    /// <returns>A list of BatchDataRequestDetails populated with as many requests stated in the parameter</returns>
    private async Task<List<BatchDataRequestDetails>> GeneratingBatchOfRequests(int requestIterations)
    {
        List<BatchDataRequestDetails> dataRequestDetails = new List<BatchDataRequestDetails>();

        string filePath = ClientHelper.FileSize(_FileSize);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string batchRequestId = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        int i = 0; 

        while(i < requestIterations)
        {

            BatchDataRequestDetails singleRequest = new BatchDataRequestDetails
            {
                ClientUnique = _ClientUnique, 
                ConnectionAlive = true, 
                DataContent = dataContent, 
                DataSize = _FileSize, 
                RequestId = Guid.NewGuid().ToString(), 
                RequestTimestamp = preciseTime, 
                RequestType = "BatchUnary",
                BatchRequestId = batchRequestId


            };

            Log.Information($"New batch data request has been added to the batch, request is owned by client ID {singleRequest.ClientUnique} with over-arching ID : {singleRequest.BatchRequestId} handles {singleRequest.RequestId}");

            dataRequestDetails.Add(singleRequest);

            i++;
        }

        return dataRequestDetails;
    }

    /// <summary>
    /// This function is in charge of gathering all the parameters to generate a DataRequest
    /// This is a unary-unary request so it's straight forward
    /// </summary>
    /// <returns></returns>
    private async Task GenerateUnaryRequest()
    {
        string filePath = ClientHelper.FileSize(_FileSize);

        string content = File.ReadAllText(filePath);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string newGuid = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        var thing = _ClientUnique;

        DataRequest newDataRequest = new DataRequest
        {
            ClientUnique = _ClientUnique, 
            ConnectionAlive = false, 
            DataContent = dataContent, 
            RequestType = "Unary", 
            DataSize = _FileSize, 
            RequestId = newGuid, 
            RequestTimestamp = preciseTime
        };

        Log.Information($"Client ID: {newDataRequest.ClientUnique} has sent message ID: {newDataRequest.RequestId} at {newDataRequest.RequestTimestamp}");

        DataResponse serverResponse = await UnaryRequestService.UnaryResponseAsync(newDataRequest, Guid.Parse(_ChannelId));

        if(serverResponse.RequestId == null || serverResponse.ClientUnique == null)
        {
            Log.Information($"Something went wrong, the server responded with no requestID or clientID"); 
        }


    }

    /// <summary>
    /// Clears all the client instances within the database based on the session unique
    /// This is currently a unary -> unary implementation
    /// </summary>
    /// <returns></returns>
    private async Task ClearClientInstances()
    {
        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        ClientListFromDb.Clear();

        GetClientInstancesFromSessionUniqueRequest request = new GetClientInstancesFromSessionUniqueRequest
        {
                SessionUnique = sessionUnique
        };

        //THIS DELETES THE CURRENT RECORDS IN A UNARY MATTER - i want to try and get this to work in a streaming fashion
        await ClientInstanceService.GetClientInstancesAsync(request);
    }

    /// <summary>
    /// Generates a list of clients, adds them to the private list with their new guid
    /// </summary>
    /// <returns></returns>
    private async Task GeneratingClientInstances()
    {
        int i = 0;

        while (i < AmountOfClients)
        {
            ClientList.Add(Guid.NewGuid());

            Log.Information($"amount of things in client list {i}");

            i++;
        }
    }


    private async Task SendClientsToBackend()
    {
        string username = await GetStringFromStringFromLocalStorage("username");

        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        string accountUnique = await GetStringFromStringFromLocalStorage("account-unique");

        await ClientInstanceService.CreatingClientInstancesStreamedAsync(sessionUnique, accountUnique, ClientList);
    }

    /// <summary>
    /// Allows for the retrieval of a string from the local storage
    /// </summary>
    /// <param name="storagekey">the key identifier of the item in local storage</param>
    /// <returns>The string value of they key specified</returns>
    private async Task<string> GetStringFromStringFromLocalStorage(string storagekey)
    {
        string? localStorageUsername = await LocalStorage.GetItemAsync<string>(storagekey);

        if(string.IsNullOrEmpty(localStorageUsername))
        {
            Log.Information($"key {storagekey} cannot be found in the local storage");
            return "";
        }

        return localStorageUsername;
    }     
    
}
