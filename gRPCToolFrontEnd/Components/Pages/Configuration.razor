@using gRPCToolFrontEnd.Components.Layout
@using gRPCToolFrontEnd.Services
@using gRPCToolFrontEnd.Helpers
@using Serilog
@using Grpc.Net.Client
@using gRPCToolFrontEnd.LocalStorage
@page "/"
@layout MainLayout
@inject ClientInstanceService ClientInstanceService
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject UnaryRequestService UnaryRequestService
@inject ClientHelper ClientHelper
@inject AccountDetailsStore AccountDetailsStore

<HeadContent>
    <link href="/Style/LoginPage.css" rel="stylesheet" />
</HeadContent>



<MudPaper Class="d-flex justify-start flex-grow-1 gap-4" Elevation="15" Style="width: 300px; padding-left: 20px; background-color: transparent;" Square="true" >

    <MudSelect T="string" Label="Request flow" MultiSelection="false" ValueChanged="@OnRequestFlowChanged" >

    @foreach (string options in _RequestFlowOptions)
    {
        <MudSelectItem T="string" Value="@options">@options</MudSelectItem>
    }

</MudSelect>

</MudPaper>


<MudPaper Class="d-flex justify-start flex-grow-1 gap-4" Elevation="15" Style="width: 300px; background-color: transparent; padding-top: 30px;" Square="true">

<MudToggleIconButton @bind-Toggled="@_StreamingOn" Icon="Icons.Material.Filled.AlarmOff" Color="@Color.Primary" ToggledIcon="@Icons.Material.Filled.AlarmOn"
                     ToggledColor="@Color.Success" title="@(_StreamingOn ? "On" : "Off")" Style="margin-top: 0; padding: 0;" />

<span>Streaming is @(_StreamingOn? "On" : "Off")</span>

    <MudToggleIconButton @bind-Toggled="@_UnaryOrBatch" Icon="Icons.Material.Filled.AlarmOff" Color="@Color.Primary" ToggledIcon="@Icons.Material.Filled.AlarmOn"
                         ToggledColor="@Color.Success" title="@(_UnaryOrBatch ? "Unary" : "Batch")" Style="margin-top: 0; padding: 0;" />

    <span>Communication type is @(_UnaryOrBatch ? "Unary" : "Batch")</span>

</MudPaper>


<MudGrid Spacing="4" Justify="Justify.Center">
    <MudItem xs="12" sm="7" >
        <MudForm @ref="form" Style="background-color: #1A1A1D" >

            <MudCard Style="background: #252525">
                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                    <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                        <MudGrid Spacing="2" >
                            <MudItem xs="12" sm="6" >
                            <MudTextField font-style="Montserrat" Class="MyMudTextField" Disabled="@_IsClientNumberDisabled" @bind-value="@AmountOfClients" T="int" Label="Client Number" Required="true" RequiredError="A client number is required!" HelperText="Input amount of client above:" Margin="Margin.Dense"></MudTextField>
                        </MudItem>
                    </MudGrid>
                </MudPaper>

                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                        <MudGrid Spacing="2"> 
                        <MudItem xs="12" sm="6">

                                <MudTextField font-style="Montserrat" Disabled="@_IsClientInstanceDisabled" @bind-value="@_ClientUnique" Class="MyMudTextField" T="string" Label="Client Instance Unique" Required="true" RequiredError="A client instance is required!" HelperText="Input client instance ID above:" Margin="Margin.Dense"></MudTextField>

                        </MudItem>
                    </MudGrid>
                </MudPaper>

                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                        <MudGrid Spacing="2"> 
                        <MudItem xs="12" sm="6">

                            <MudTextField font-style="Montserrat" @bind-value="@_FileSize" Class="MyMudTextField" T="string" Label="File Size" Required="true" RequiredError="A file size of small, medium or large is required!" HelperText="Input file size above:" Margin="Margin.Dense"></MudTextField>

                        </MudItem>
                    </MudGrid>
                </MudPaper>

                <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                        <MudGrid Spacing="2"> 
                        <MudItem xs="12" sm="6">

                            <MudTextField font-style="Montserrat" Disabled="@_IsBatchIterationsDisabled" @bind-value="@_Iterations" Class="MyMudTextField" T="int" Label="Batch Iterations" Required="true" RequiredError="A number of batch iterations is required!" HelperText="Input number of batch iterations above:" Margin="Margin.Dense"></MudTextField>

                        </MudItem>
                    </MudGrid>
                </MudPaper>
            </MudPaper>
            </MudCard>

            <MudPaper Style="background: rgba(20, 20, 20, 0.9)">
                <MudGrid Spacing="2"> 
                    <MudItem xs="12" sm="6">

                        <MudTextField font-style="Montserrat" @bind-value="@_ChannelId" Class="MyMudTextField" T="string" Label="Channel ID" Required="true" RequiredError="A channel ID is required!" HelperText="Input channel ID above:" Margin="Margin.Dense"></MudTextField>

                    </MudItem>
                </MudGrid>
            </MudPaper>

            <MudPaper Class="pa-4 mt-4 justify-start" Style="background: rgba(20, 20, 20, 0.9)">
                <MudGrid Spacing="6" Justify="Justify.SpaceEvenly">

                    <MudItem>
                        <MudTooltip Text="This will apply the current configuration settings"> 
                            <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="true" @onclick="@GenerateClients" Disabled="@_IsApplyConfigDisabled">Apply Configuration Settings</MudButton>
                        </MudTooltip>
                    </MudItem>


                    <MudItem> 
                        <MudTooltip Text="This will clear all of the client instances"> 
                            <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@ClearClientInstances">Clear Client Instances</MudButton>
                        </MudTooltip>
                    </MudItem>

                    <MudItem>
                        <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@SendUnaryRequest" Disabled="@_IsUnaryRequestDisabled">Send single unary request</MudButton>
                    </MudItem>

                    <MudItem> 
                        <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@SendBatchUnaryRequest" Disabled="@_IsBatchRequestDisabled">Send batch unary request</MudButton>
                    </MudItem>

                    <MudItem>
                        <MudButton Style="width: 200px;" FullWidth="true" Class="MyLoginMudButton" Variant="Variant.Filled" DropShadow="false" @onclick="@ManyClientsUnaryRequestAsync">Send many to one request</MudButton>
                    </MudItem>
                
            
                </MudGrid>
            </MudPaper>

        </MudForm>
    </MudItem>
</MudGrid>

@code {

    //essentially what we're going to want on this page is for the user to be able to generate as many clients as he wants
    //stores them in a DS locally which we can then call to populate the database with the clients that are created

    MudForm form;


    private int AmountOfClients;

    private int _Iterations;

    private string _ClientUnique;

    private string _FileSize;

    private string _ChannelId;

    private string _RequestFlow;

    private bool _IsBatchRequestDisabled;

    private bool _IsUnaryRequestDisabled;

    private bool _IsApplyConfigDisabled;

    private bool _IsClientInstanceDisabled; 

    private bool _IsBatchIterationsDisabled; 

    private bool _IsClientNumberDisabled;

    public bool _StreamingOn { get; set; } = true;

    public bool _UnaryOrBatch { get; set; } = true;


    /// <summary>
    /// This list holds all of the options for the mudblazor mudselect 
    /// one : one -> one channel, one client instance, one request (single unary)
    /// one : many -> one channel, one client instance, one batch request (batch request unary)
    /// many : one -> many channels, many client instances, one request on each channel 
    /// many : many -> many channels, many client instances, many requests on each channel (can be a mix of batch / single / sequential)
    /// </summary>
    private List<string> _RequestFlowOptions = new List<string>()
    {
        "one : one",
        "one : many",
        "many : one",
        "many : many"
    };


    private List<Guid> ClientList = new List<Guid>();

    private List<Guid> ClientListFromDb = new List<Guid>();

    private async Task OnRequestFlowChanged(string value)
    {
        Log.Information($"Selected Request Flow: {value}");
        _RequestFlow = value;
        await HandlingCommunications();
    }

    //need to create a load balancer, this currently handles one channel - one requets / bulk request
    //iterate over the channels list based on streaming state use unary batch -> once / unary once

    private async Task ManyClientsUnaryRequestAsync()
    {

        //need a dropdown thing for unary or batch ig

        Log.Information($"Many to one logs");
        Log.Information($"Streaming state: {_StreamingOn}");
        Log.Information($"Request flow: {_RequestFlow}"); 
        Log.Information($"Unary or batch state: {_UnaryOrBatch}"); 
        Log.Information($"Num of channels in list: {AccountDetailsStore.channels.Count}");

        await ManyClientsUnaryRequest(_StreamingOn, _RequestFlow, _UnaryOrBatch, AccountDetailsStore.channels);
    }

    //we need some determinant for if we send a unary or batch
    public async Task ManyClientsUnaryRequest(bool isStreaming, string dropDownState, bool unaryOrBatch, Dictionary<Guid, GrpcChannel> channelDict)
    {
        if (!isStreaming && dropDownState == "many : one" )
        {
          
             foreach (var channel in channelDict)
             {
                 await DetermingUnaryOrBatchRequest(unaryOrBatch);
             }
            
        }
        
    }

    private async Task DetermingUnaryOrBatchRequest(bool unaryOrBatch)
    {
        if (unaryOrBatch)
        {
            await SendUnaryRequest();
        }
        else
        {
            await SendBatchUnaryRequest();
        }

    }

    /// <summary>
    /// This is used on the batch unary request and the single unary request 
    /// Since we only really need to generate mass amount of clients for one to many or many to many request types 
    /// Singular requests should just have a client instance created for them
    /// </summary>
    /// <returns></returns>
    private async Task<string> CreateSingularClientInstance()
    {

        string username = await GetStringFromStringFromLocalStorage("username");

        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        CreateClientInstanceRequest newClientInstance = new CreateClientInstanceRequest
        {
             Username = username,
             SessionUnique = sessionUnique
        };

        CreateClientInstanceResponse serverResponse = await ClientInstanceService.CreateClientInstanceAsync(newClientInstance);

        if(serverResponse.SessionUnique == null)
        {
            Log.Warning($"Something went wrong when creating a singular client instance");
        }

        return serverResponse.ClientUnique;
    }

    /// <summary>
    /// this is used as the overhead method for generating clients
    /// All it does is generate a number of clients determined by the client 
    /// And then sends them to the server to be stored in the database
    /// </summary>
    /// <returns></returns>
    private async Task GenerateClients()
    {
        await GeneratingClientInstances();

        await SendClientsToBackend();
    }

    /// <summary>
    /// This is used for sending a single unary request on a single channel
    /// A new unary client instance is generated in the service of this method call every time the endpoint is activated
    /// </summary>
    /// <returns></returns>
    private async Task SendUnaryRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique;

        await GenerateUnaryRequest();
    }

    /// <summary>
    /// This is used for sending a batch unary request on a single channel
    /// A new unary client instance is generated in the service of this method call every tim the endpoint is activated
    /// </summary>
    /// <returns></returns>
    private async Task SendBatchUnaryRequest()
    {
        string clientUnique = await CreateSingularClientInstance();

        _ClientUnique = clientUnique; 

        await GenerateBatchUnaryRequest();
    }

    //we need to create the functionality for hanlding the different types of communication flow

    /// <summary>
    /// Handles the communication flow of the forms on the front end depending on what drop down option is currently selected 
    /// Essentially just flips between true and false to disable buttons and input fields
    /// Then calls StateHasChanged to force a page refresh
    /// </summary>
    /// <returns></returns>
    public async Task HandlingCommunications()
    {
        Log.Information($"HandlingCommunications called with _RequestFlow: {_RequestFlow}");

        switch (_RequestFlow)
        {
            case "one : one":
                _IsBatchRequestDisabled = true;
                _IsUnaryRequestDisabled = false;
                _IsApplyConfigDisabled = true;
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = true;
                _IsClientNumberDisabled = true;
                break;

            case "one : many":
                _IsUnaryRequestDisabled = false;
                _IsBatchRequestDisabled = false;
                _IsApplyConfigDisabled = true;
                _IsClientNumberDisabled = true; 
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                break;

            case "many : one":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                _IsClientNumberDisabled = true;
                _IsBatchRequestDisabled = true;
                break;

            case "many : many":
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                _IsClientInstanceDisabled = true;
                _IsBatchIterationsDisabled = false;
                break;

            default:
                _IsBatchRequestDisabled = false;
                _IsUnaryRequestDisabled = false;
                break;
        }

        StateHasChanged();
    } 

    /// <summary>
    /// This method is in charge of generating handling a list of BatchDataRequestDetails, adding them to the request as this is a repeated field (bulk upload to the server)
    /// 
    /// </summary>
    /// <returns></returns>
    private async Task GenerateBatchUnaryRequest()
    {

        List<BatchDataRequestDetails> dataRequestDetails = await GeneratingBatchOfRequests(_Iterations);

        Log.Information($"Amount of requests in the data request list: {dataRequestDetails.Count}");

        BatchDataRequest batchDataRequestUnary = new BatchDataRequest
        {
             BatchDataRequest_ = { dataRequestDetails }
        };

        await UnaryRequestService.UnaryBatchResponseAsync(batchDataRequestUnary, _Iterations, Guid.Parse(_ChannelId));
    }

    /// <summary>
    /// This method is in charge of generating each request that goes into the batch of unary requests 
    /// While loop to generate the requests until we reach the amount of requests required in the batch
    /// </summary>
    /// <param name="requestIterations"> is how many messages you want to be in the batch</param>
    /// <returns>A list of BatchDataRequestDetails populated with as many requests stated in the parameter</returns>
    private async Task<List<BatchDataRequestDetails>> GeneratingBatchOfRequests(int requestIterations)
    {
        List<BatchDataRequestDetails> dataRequestDetails = new List<BatchDataRequestDetails>();

        string filePath = ClientHelper.FileSize(_FileSize);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string requestId = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        int i = 0; 

        while(i < requestIterations)
        {

            BatchDataRequestDetails singleRequest = new BatchDataRequestDetails
            {
                ClientUnique = _ClientUnique, 
                ConnectionAlive = true, 
                DataContent = dataContent, 
                DataSize = _FileSize, 
                RequestId = requestId, 
                RequestTimestamp = preciseTime, 
                RequestType = "BatchUnary"

            };

            Log.Information($"New batch data request has been added to the batch, request is owned by client ID {singleRequest.ClientUnique} handles message {singleRequest.RequestId}");

            dataRequestDetails.Add(singleRequest);

            i++;
        }

        return dataRequestDetails;
    }

    /// <summary>
    /// This function is in charge of gathering all the parameters to generate a DataRequest
    /// This is a unary-unary request so it's straight forward
    /// </summary>
    /// <returns></returns>
    private async Task GenerateUnaryRequest()
    {
        string filePath = ClientHelper.FileSize(_FileSize);

        string content = File.ReadAllText(filePath);

        string dataContent = ClientHelper.DataContentCalc(_FileSize);

        string newGuid = Guid.NewGuid().ToString();

        var now = DateTime.UtcNow;
        long ticks = now.Ticks;
        string preciseTime = now.ToString("HH:mm:ss.ffffff");

        var thing = _ClientUnique;

        DataRequest newDataRequest = new DataRequest
        {
            ClientUnique = _ClientUnique, 
            ConnectionAlive = false, 
            DataContent = dataContent, 
            RequestType = "Unary", 
            DataSize = _FileSize, 
            RequestId = newGuid, 
            RequestTimestamp = preciseTime
        };

        Log.Information($"Client ID: {newDataRequest.ClientUnique} has sent message ID: {newDataRequest.RequestId} at {newDataRequest.RequestTimestamp}");

        DataResponse serverResponse = await UnaryRequestService.UnaryResponseAsync(newDataRequest, Guid.Parse(_ChannelId));

        if(serverResponse.RequestId == null || serverResponse.ClientUnique == null)
        {
            Log.Information($"Something went wrong, the server responded with no requestID or clientID"); 
        }


    }

    /// <summary>
    /// Clears all the client instances within the database based on the session unique 
    /// </summary>
    /// <returns></returns>
    private async Task ClearClientInstances()
    {
        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        ClientListFromDb.Clear();

        GetClientInstancesFromSessionUniqueRequest request = new GetClientInstancesFromSessionUniqueRequest
            {
                SessionUnique = sessionUnique
            };

        //await ClientInstanceService.GetClientInstancesViaSessionUnique(request, ClientListFromDb);

        //THIS DELETES THE CURRENT RECORDS IN A UNARY MATTER - i want to try and get this to work in a streaming fashion
        await ClientInstanceService.GetClientInstancesAsync(request);

        //await ClientInstanceService.ClearingClientInstancesStreamedAsync(sessionUnique, ClientListFromDb);
    }

    private async Task GeneratingClientInstances()
    {
        int i = 0;

        while (i < AmountOfClients)
        {
            ClientList.Add(Guid.NewGuid());

            Log.Information($"amount of things in client list {i}");

            i++;
        }
    }


    private async Task SendClientsToBackend()
    {
        string username = await GetStringFromStringFromLocalStorage("username");

        string sessionUnique = await GetStringFromStringFromLocalStorage("session-unique");

        string accountUnique = await GetStringFromStringFromLocalStorage("account-unique");

        await ClientInstanceService.CreatingClientInstancesStreamedAsync(sessionUnique, accountUnique, ClientList);
    }

    private async Task<string> GetStringFromStringFromLocalStorage(string storagekey)
    {
        string? localStorageUsername = await LocalStorage.GetItemAsync<string>(storagekey);

        if(string.IsNullOrEmpty(localStorageUsername))
        {
            Log.Information($"key {storagekey} cannot be found in the local storage");
        }

        return localStorageUsername;
    }

    

        
    
}
